(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{426:function(e,t,r){e.exports=r.p+"assets/img/layers.94051684.png"},427:function(e,t,r){e.exports=r.p+"assets/img/flow.654f5c05.png"},428:function(e,t,r){e.exports=r.p+"assets/img/webkitflow.b2b7c07b.png"},429:function(e,t,r){e.exports=r.p+"assets/img/image008.06086844.jpg"},682:function(e,t,r){"use strict";r.r(t);var a=r(29),n=Object(a.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"前提概要"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前提概要"}},[e._v("#")]),e._v(" 前提概要")]),e._v(" "),a("p",[e._v("浏览器是到底是怎么工作的，相信大多数前端小伙伴对具体的工作流程比较模糊，我尝试翻译这边英文文档，来较为详细介绍浏览器工作的具体流程。09年的文章较早。")]),e._v(" "),a("h3",{attrs:{id:"介绍"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[e._v("#")]),e._v(" 介绍")]),e._v(" "),a("p",[e._v("web 浏览器可能是使用最广泛的软件。在这边文章中，我会解释他们在底层是如何工作的。 我们将会看到，当你在浏览器地址栏上输入‘google.com’一直到你再浏览区屏幕中看到 Google 页面中发生了什么。")]),e._v(" "),a("h4",{attrs:{id:"我们将要谈论的浏览器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#我们将要谈论的浏览器"}},[e._v("#")]),e._v(" 我们将要谈论的浏览器")]),e._v(" "),a("p",[e._v("当今五款主流的浏览器----- Internet Explorer, Firefox, Safari, Chrome and Opera.\n我会给出这些开源浏览器中的例子 ------- Firefox,Chrome and Safari 都是部分开源的\n根据W3C的浏览器统计数据，目前(2009年10月)，Firefox、Safari和Chrome的使用份额加起来接近60%。\n所以现在开源浏览器是浏览器业务的重要组成部分。")]),e._v(" "),a("h4",{attrs:{id:"浏览器的主要功能"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器的主要功能"}},[e._v("#")]),e._v(" 浏览器的主要功能")]),e._v(" "),a("p",[e._v("浏览器的主要功能是通过向服务器请求并在浏览器窗口中显示所选择的web资源来显示它。资源格式通常是HTML，但也有PDF、图像等。资源的位置由用户使用URI(统一资源标识符)指定。更多信息请参见网络章节。")]),e._v(" "),a("p",[e._v("浏览器解释和显示HTML文件的方式在HTML和CSS规范中指定。这些规范由W3C(万维网联盟)组织维护，该组织是万维网的标准组织。\nHTML的当前版本是4 (http://www.w3.org/TR/html401/)。版本5正在进行中。当前CSS版本为2 (http://www.w3.org/TR/CSS2/)，版本3正在进行中。\n多年来，浏览器只遵循部分规范，并开发了自己的扩展。这给网络作者带来了严重的兼容性问题。如今，大多数浏览器或多或少都符合规范。")]),e._v(" "),a("p",[e._v("浏览器的用户界面彼此之间有很多共同之处。常见的用户界面元素有:")]),e._v(" "),a("ul",[a("li",[e._v("插入URI的地址栏")]),e._v(" "),a("li",[e._v("后退和前进按钮")]),e._v(" "),a("li",[e._v("书签选项")]),e._v(" "),a("li",[e._v("用于刷新和停止加载当前文档的刷新和停止按钮")]),e._v(" "),a("li",[e._v("主页按钮，让您进入您的主页")])]),e._v(" "),a("p",[e._v("奇怪的是，浏览器的用户界面并没有在任何正式规范中指定，它只是多年的经验和浏览器相互模仿形成的良好实践。HTML5规范没有定义浏览器必须拥有的UI元素，但列出了一些常见元素。其中包括地址栏、状态栏和工具栏。当然，有一些特定浏览器特有的功能，比如Firefox下载管理器。\n在用户界面那一章有更多的介绍。")]),e._v(" "),a("h4",{attrs:{id:"浏览器的上层结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器的上层结构"}},[e._v("#")]),e._v(" 浏览器的上层结构")]),e._v(" "),a("p",[e._v("浏览器的主要组件是:")]),e._v(" "),a("ul",[a("li",[e._v("用户界面（User Interface）-这包括地址栏，后退/前进按钮，书签菜单等。除了主窗口之外，浏览器的所有部分都显示出来，在主窗口中您可以看到请求的页面。")]),e._v(" "),a("li",[e._v("浏览器引擎(Browser engine)——查询和操作呈现引擎的界面。")]),e._v(" "),a("li",[e._v("渲染引擎(Rendering engine)——负责显示请求的内容。例如，如果请求的内容是HTML，则它负责解析HTML和CSS，并在屏幕上显示解析后的内容。")]),e._v(" "),a("li",[e._v("网络(Networing)——用于网络调用，如HTTP请求。它有平台独立的接口和每个平台的底层实现。")]),e._v(" "),a("li",[e._v("UI后端(UI Backend)——用于绘制基本的小部件，如组合框和窗口。它公开了一个非特定于平台的通用接口。在底层，它使用操作系统用户界面方法。")]),e._v(" "),a("li",[e._v("JavaScript解释器(JavaScript Interpreter)。用于解析和执行JavaScript代码。")]),e._v(" "),a("li",[e._v("数据存储。这是一个持久层。浏览器需要在硬盘上保存各种数据，例如cookie。新的HTML规范(HTML5)定义了“web数据库”，它是浏览器中一个完整的(尽管很轻)数据库。\n"),a("img",{attrs:{src:r(426),alt:"avatar"}})])]),e._v(" "),a("p",[e._v("需要注意的是，不同于大多数浏览器,chrome 拥有多个渲染引擎实例每个标签一个。每个标签是一个独立的进程。")]),e._v(" "),a("p",[e._v("我将用一章来介绍这些组成部分。")]),e._v(" "),a("p",[e._v("组件之间的通信：\n火狐和Chrome都开发了特殊的通信基础设施。\n它们将在专门的一章中加以讨论。")]),e._v(" "),a("h4",{attrs:{id:"渲染引擎"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#渲染引擎"}},[e._v("#")]),e._v(" 渲染引擎")]),e._v(" "),a("p",[e._v("渲染引擎的职责是…呈现，即在浏览器屏幕上显示所请求的内容。\n默认情况下，渲染引擎可以显示HTML和XML文档和图像。它可以通过插件(浏览器扩展)显示其他类型。一个示例是使用PDF查看器插件显示PDF。我们将在一个特别的章节中讨论插件和扩展。在本章中，我们将重点关注主要用例——使用CSS格式显示HTML和图像。")]),e._v(" "),a("h5",{attrs:{id:"渲染引擎-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#渲染引擎-2"}},[e._v("#")]),e._v(" 渲染引擎")]),e._v(" "),a("p",[e._v("我们的参考浏览器---- Firefox, Chrome和Safari是建立在两个渲染引擎。Firefox使用Gecko——一个“自制”的Mozilla渲染引擎。Safari和Chrome都使用Webkit。\nWebkit是一个开源的渲染引擎，最初是一个Linux平台的引擎，后来被苹果公司修改以支持Mac和Windows。详情请参阅http://webkit.org/。")]),e._v(" "),a("h5",{attrs:{id:"主要流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#主要流程"}},[e._v("#")]),e._v(" 主要流程")]),e._v(" "),a("p",[e._v("The rendering engine will start getting the contents of the requested document from the networking layer. This will usually be done in 8K chunks.")]),e._v(" "),a("p",[e._v("After that this is the basic flow of the rendering engine:")]),e._v(" "),a("p",[e._v("渲染引擎从网络层获取所请求文档的内容。这通常是在 8k 块中完成的。\n"),a("img",{attrs:{src:r(427),alt:"avatar"}})]),e._v(" "),a("p",[e._v('The rendering engine will start parsing the HTML document and turn the tags to DOM nodes in a tree called the "content tree". It will parse the style data, both in external CSS files and in style elements. The styling information together with visual instructions in the HTML will be used to create another tree - the render tree.')]),e._v(" "),a("p",[e._v("渲染引擎将开始解析HTML文档，并将标记转换为“内容树”中的DOM节点。它将解析样式数据，包括外部CSS文件和样式元素。样式信息和HTML中的视觉指令将被用来创建另一棵树——呈现树。")]),e._v(" "),a("p",[e._v("The render tree contains rectangles with visual attributes like color and dimensions. The rectangles are in the right order to be displayed on the screen.")]),e._v(" "),a("p",[e._v("渲染树包含具有颜色和尺寸等视觉属性的矩形。矩形以正确的顺序显示在屏幕上。")]),e._v(" "),a("p",[e._v('After the construction of the render tree it goes through a "layout" process. This means giving each node the exact coordinates where it should appear on the screen. The next stage is painting - the render tree will be traversed and each node will be painted using the UI backend layer.')]),e._v(" "),a("p",[e._v("在构建完渲染树之后，它经历了一个“布局”过程。这意味着给每个节点在屏幕上应该出现的确切坐标。下一个阶段是绘制—渲染树将被遍历，每个节点将使用UI后端层进行绘制。")]),e._v(" "),a("p",[e._v("It's important to understand that this is a gradual process. For better user experience, the rendering engine will try to display contents on the screen as soon as possible. It will not wait until all HTML is parsed before starting to build and layout the render tree. Parts of the content will be parsed and displayed, while the process continues with the rest of the contents that keeps coming from the network.\n重要的是要明白这是一个渐进的过程。为了更好的用户体验，渲染引擎会尽可能快地在屏幕上显示内容。它不会等到所有的HTML都被解析后才开始构建和布局渲染树。部分内容将被解析和显示，而剩下的内容将继续解析和显示。\nwebkit workflow\n"),a("img",{attrs:{src:r(428),alt:"avatar"}})]),e._v(" "),a("p",[e._v("Mozilla's Gecko rendering engine main flow\n"),a("img",{attrs:{src:r(429),alt:"avatar"}})]),e._v(" "),a("p",[e._v("从图3和图4中可以看出，尽管Webkit和Gecko使用的术语略有不同，但流程基本上是相同的。\nGecko将可视化格式的元素称为树——框架树。每个元素都是一个框架。Webkit使用术语“渲染树”，它由“渲染对象”组成。Webkit使用术语“布局”来表示元素的放置，而Gecko称之为“回流”。“附件”是Webkit术语，用来连接DOM节点和视觉信息来创建渲染树。一个非语义的小区别是，Gecko在HTML和DOM树之间有一个额外的层。它被称为“内容接收器”，是制造DOM元素的工厂。我们将讨论流程的每个部分:")]),e._v(" "),a("h3",{attrs:{id:"参考"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[e._v("#")]),e._v(" 参考")]),e._v(" "),a("p",[e._v("http://taligarsiel.com/Projects/howbrowserswork1.htm")])])}),[],!1,null,null,null);t.default=n.exports}}]);